import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
import pandas as pd
import sys
import os

# Ensure we can import from the current directory
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from main import simulate_python

# Constants matching main.cp
l1 = 2
l2 = 1

def get_coords(th1, th2):
    x1 = l1 * np.sin(th1)
    y1 = -l1 * np.cos(th1)
    x2 = x1 + l2 * np.sin(th2)
    y2 = y1 - l2 * np.cos(th2)
    return x1, y1, x2, y2

def visualize():
    # Read the data generated by the C++ program
    try:
        data = pd.read_csv('pendulum.csv')
    except FileNotFoundError:
        # Check if it is in the parent directory or src? Assume current working dir or similar
        # If running from root, it might be in root. If running from src, it might be in src.
        # Let's try to look in obvious places
        if os.path.exists('src/pendulum.csv'):
            data = pd.read_csv('src/pendulum.csv')
        elif os.path.exists('../pendulum.csv'):
            data = pd.read_csv('../pendulum.csv')
        else:
            print("Error: pendulum.csv not found. Please run main.exe/main.cp first.")
            return

    t_cpp = data['t'].values
    th1_cpp = data['th1'].values
    th2_cpp = data['th2'].values

    # Calculate coordinates for C++
    x1_cpp, y1_cpp, x2_cpp, y2_cpp = get_coords(th1_cpp, th2_cpp)

    # Get Python Simulation Data
    print("Running Python simulation for comparison...")
    t_py, x1_py, y1_py, x2_py, y2_py = simulate_python()

    # Setup plot
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_facecolor("k")
    ax.set_xlim(-4, 4)
    ax.set_ylim(-4, 4)
    ax.set_aspect('equal')
    ax.grid(False)
    
    # Remove ticks for cleaner look
    ax.set_xticks([])
    ax.set_yticks([])

    # Plot elements
    # C++ Pendulum (Red)
    ln_cpp, = ax.plot([], [], 'ro-', lw=3, markersize=8, label='C++')
    
    # Python Pendulum (Cyan, slightly transparent)
    ln_py, = ax.plot([], [], 'c.--', lw=2, markersize=6, alpha=0.7, label='Python')

    time_text = ax.text(0.05, 0.95, '', transform=ax.transAxes, color='white')
    ax.legend(loc='upper right')
    
    # Trace logic (optional, adds a trail) - Let's just trace C++ for clarity or both?
    # Let's trace C++ in yellow as before
    trace, = ax.plot([], [], 'y-', lw=1, alpha=0.5)
    trace_x, trace_y = [], []
    max_trace_len = 100

    def init():
        ln_cpp.set_data([], [])
        ln_py.set_data([], [])
        trace.set_data([], [])
        time_text.set_text('')
        return ln_cpp, ln_py, trace, time_text

    def animate(i):
        # Handle different lengths if necessary (though they should be same 1001)
        # Use python index if within bounds, else last
        idx_py = min(i, len(t_py) - 1)
        idx_cpp = min(i, len(t_cpp) - 1)

        # C++ positions
        cpp_x = [0, x1_cpp[idx_cpp], x2_cpp[idx_cpp]]
        cpp_y = [0, y1_cpp[idx_cpp], y2_cpp[idx_cpp]]
        ln_cpp.set_data(cpp_x, cpp_y)
        
        # Python positions
        py_x = [0, x1_py[idx_py], x2_py[idx_py]]
        py_y = [0, y1_py[idx_py], y2_py[idx_py]]
        ln_py.set_data(py_x, py_y)

        # Update trace (C++ trace)
        trace_x.append(x2_cpp[idx_cpp])
        trace_y.append(y2_cpp[idx_cpp])
        if len(trace_x) > max_trace_len:
            trace_x.pop(0)
            trace_y.pop(0)
        trace.set_data(trace_x, trace_y)

        time_text.set_text(f'Time: {t_cpp[idx_cpp]:.2f}s')
        return ln_cpp, ln_py, trace, time_text

    # Create animation
    # Interval roughly matches real time if possible, but depends on dt
    # main.cp has 40s over 1001 steps => dt = 0.04s = 40ms
    frames = max(len(t_cpp), len(t_py))
    ani = animation.FuncAnimation(fig, animate, frames=frames,
                                  init_func=init, interval=40, blit=True)

    print("Showing animation...")
    plt.show()

if __name__ == "__main__":
    visualize()
